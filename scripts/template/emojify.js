/* This file is generated by a script at build time.
 * do not modify it manually. */
import emojiRegex from "emoji-regex/es2015";

// prettier-ignore
const EMOJIS = process.env.EMOJIS;
// prettier-ignore
const GROUPS = process.env.GROUPS;
// prettier-ignore
const SKIN_TONE_VARIATIONS = ["1F3FB", "1F3FC", "1F3FD", "1F3FE", "1F3FF"];
const EMOJI_BY_SHORTNAME = Object.fromEntries(
	Object.entries(EMOJIS).map((tuple) => tuple.reverse()),
);
const SHORTNAME_RE = new RegExp(
	`:(${Object.values(EMOJIS)
		.map((shortname) => shortname.replace(/[()]/g, "\\$&"))
		.join("|")}):`,
	"g",
);
const UNICODE_RE = emojiRegex();

function toCodePoints(emoji) {
	return [...emoji].map((c) => c.codePointAt(0).toString(16)).join("-");
}

/* Public API */

/**
 * Convert all unicode empjis (such as ðŸš½) to their shortNames equivalent (:toilet:)
 * @param {String} unicode some text containing unicode emojis
 * @returns {String} converted text.
 */
export function unicodeToShortname(text) {
	if (!text) {
		return text;
	}
	return text.replace(UNICODE_RE, (match) => `:${EMOJIS[match]}: `).trim();
}

/**
 * Convert a shortname representation to its unicode emoji
 * @param {String} text some shortname
 * @returns {String} the corresponding unicode emoji. If not found, returns the shortname.
 */
export function shortnameToUnicode(text) {
	if (!text) {
		return text;
	}
	return text.replace(SHORTNAME_RE, (match, name) => {
		const emoji = EMOJI_BY_SHORTNAME[name];
		return emoji || match;
	});
}

/**
 * Standardiztion of all unicode emojis.
 * We first transform all of them to shortNames, and then convert them back
 * to unicode.
 * @param String some text
 * @return String normalized text
 */
export function unifyUnicode(text) {
	text = unicodeToShortname(text);
	text = shortnameToUnicode(text);
	return text;
}

/**
 * Returns a boolean value depending if text contains or not some emojis of any type
 * @param String some text
 * @return Boolean
 */
export function test(text) {
	UNICODE_RE.lastIndex = 0; // TODO: check if needed here
	return SHORTNAME_RE.test(text) || UNICODE_RE.test(text);
}

/**
 * Parse some text to find all type of emojis
 * It will detect 3 kind of emojis/emoticons:
 * - Unicode emojis like ðŸš½,ðŸ¦„,ðŸ’©
 * - shortnames emojis such as :toilet:, :poop:, :fries:
 * @param String some text to parse
 * @return a list of entities containing information regarding detected emojis or null
 */
export function parse(text) {
	let emojis = [];
	// Shortnames
	text.replace(SHORTNAME_RE, (match, shortname, offset) => {
		const emoji = EMOJI_BY_SHORTNAME[shortname];
		emojis.push({
			text: emoji,
			shortname: match,
			codePoints: toCodePoints(emoji),
			indices: [offset, offset + match.length],
		});
	});

	// Unicode - can't use replace() here. We need to rely on RegExp.lastIndex
	// to compute actual indices. Length for multi-codepoints emoji can be tricky
	UNICODE_RE.lastIndex = 0;
	while (true) {
		const result = UNICODE_RE.exec(text);
		if (!result) {
			break;
		}
		emojis.push({
			text: result[0],
			shortname: `:${EMOJIS[result[0]]}:`,
			codePoints: toCodePoints(result[0]),
			indices: [result.index, UNICODE_RE.lastIndex],
		});
	}
	return emojis.length > 0
		? emojis.sort((a, b) =>
				a.indices[0] > b.indices[0]
					? 1
					: a.indices[0] < b.indices[0]
					? -1
					: 0,
		  )
		: null;
}
